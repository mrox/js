//
//  Copyright (c) 2014 Sam Leitch. All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to
//  deal in the Software without restriction, including without limitation the
//  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
//  IN THE SOFTWARE.
//

// modified by Matthias Behrens (github.com/soliton4) for Broadway.js


// universal module definition
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.WebGLCanvas = factory();
    }
}(this, function () {


/**
 * This class can be used to render output pictures from an H264bsdDecoder to a canvas element.
 * If available the content is rendered using WebGL.
 */
function H264bsdCanvas(canvas, forceNoGL) {
    this.canvasElement = canvas;

    if(!forceNoGL) this.initContextGL();

    if(this.contextGL) {
        this.initProgram();
        this.initBuffers();
        this.initTextures();
    }
}

/**
 * Returns true if the canvas supports WebGL
 */
H264bsdCanvas.prototype.isWebGL = function() {
    return this.contextGL;
};

/**
 * Create the GL context from the canvas element
 */
H264bsdCanvas.prototype.initContextGL = function() {
    var canvas = this.canvasElement;
    var gl = null;

    var validContextNames = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
    var nameIndex = 0;

    while(!gl && nameIndex < validContextNames.length) {
        var contextName = validContextNames[nameIndex];
        
        try {
            gl = canvas.getContext(contextName);
        } catch (e) {
            gl = null;
        }

        if(!gl || typeof gl.getParameter !== "function") {
            gl = null;
        }    

        ++nameIndex;
    }
 
    this.contextGL = gl;
};

/**
 * Initialize GL shader program
 */
H264bsdCanvas.prototype.initProgram = function() {
    var gl = this.contextGL;

    var vertexShaderScript = [
        'attribute vec4 vertexPos;',
        'attribute vec4 texturePos;',
        'varying vec2 textureCoord;',

        'void main()',
        '{',
            'gl_Position = vertexPos;',
            'textureCoord = texturePos.xy;',
        '}'
        ].join('\n');

    var fragmentShaderScript = [
        'precision highp float;',
        'varying highp vec2 textureCoord;',
        'uniform sampler2D ySampler;',
        'uniform sampler2D uSampler;',
        'uniform sampler2D vSampler;',
        'const mat4 YUV2RGB = mat4',
        '(',
            '1.1643828125, 0, 1.59602734375, -.87078515625,',
            '1.1643828125, -.39176171875, -.81296875, .52959375,',
            '1.1643828125, 2.017234375, 0, -1.081390625,',
            '0, 0, 0, 1',
        ');',
      
        'void main(void) {',
            'highp float y = texture2D(ySampler,  textureCoord).r;',
            'highp float u = texture2D(uSampler,  textureCoord).r;',
            'highp float v = texture2D(vSampler,  textureCoord).r;',
            'gl_FragColor = vec4(y, u, v, 1) * YUV2RGB;',
        '}'
        ].join('\n');

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderScript);
    gl.compileShader(vertexShader);
    if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.log('Vertex shader failed to compile: ' + gl.getShaderInfoLog(vertexShader));
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderScript);
    gl.compileShader(fragmentShader);
    if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.log('Fragment shader failed to compile: ' + gl.getShaderInfoLog(fragmentShader));
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.log('Program failed to compile: ' + gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);
    
    this.shaderProgram = program;
};

/**
 * Initialize vertex buffers and attach to shader program
 */
H264bsdCanvas.prototype.initBuffers = function() {
    var gl = this.contextGL;
    var program = this.shaderProgram;

    var vertexPosBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), gl.STATIC_DRAW);

    var vertexPosRef = gl.getAttribLocation(program, 'vertexPos');
    gl.enableVertexAttribArray(vertexPosRef);
    gl.vertexAttribPointer(vertexPosRef, 2, gl.FLOAT, false, 0, 0);

    var texturePosBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texturePosBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);

    var texturePosRef = gl.getAttribLocation(program, 'texturePos');
    gl.enableVertexAttribArray(texturePosRef);
    gl.vertexAttribPointer(texturePosRef, 2, gl.FLOAT, false, 0, 0);

    this.texturePosBuffer = texturePosBuffer;
};

/**
 * Initialize GL textures and attach to shader program
 */
H264bsdCanvas.prototype.initTextures = function() {
    var gl = this.contextGL;
    var program = this.shaderProgram;

    var yTextureRef = this.initTexture();
    var ySamplerRef = gl.getUniformLocation(program, 'ySampler');
    gl.uniform1i(ySamplerRef, 0);
    this.yTextureRef = yTextureRef;

    var uTextureRef = this.initTexture();
    var uSamplerRef = gl.getUniformLocation(program, 'uSampler');
    gl.uniform1i(uSamplerRef, 1);
    this.uTextureRef = uTextureRef;

    var vTextureRef = this.initTexture();
    var vSamplerRef = gl.getUniformLocation(program, 'vSampler');
    gl.uniform1i(vSamplerRef, 2);
    this.vTextureRef = vTextureRef;
};

/**
 * Create and configure a single texture
 */
H264bsdCanvas.prototype.initTexture = function() {
    var gl = this.contextGL;

    var textureRef = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, textureRef);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);

    return textureRef;
};

/**
 * Draw picture data to the canvas.
 * If this object is using WebGL, the data must be an I420 formatted ArrayBuffer,
 * Otherwise, data must be an RGBA formatted ArrayBuffer.
 */
H264bsdCanvas.prototype.drawNextOutputPicture = function(width, height, croppingParams, data) {
    var gl = this.contextGL;

    if(gl) {
        this.drawNextOuptutPictureGL(width, height, croppingParams, data);
    } else {
        this.drawNextOuptutPictureRGBA(width, height, croppingParams, data);
    }
};

H264bsdCanvas.prototype.draw = function(width, height, croppingParams, data) {
    this.drawNextOuptutPictureGL(width, height, croppingParams, data.buffer);
}

/**
 * Draw the next output picture using WebGL
 */
H264bsdCanvas.prototype.drawNextOuptutPictureGL = function(width, height, croppingParams, data) {
    var gl = this.contextGL;
    var texturePosBuffer = this.texturePosBuffer;
    var yTextureRef = this.yTextureRef;
    var uTextureRef = this.uTextureRef;
    var vTextureRef = this.vTextureRef;    

    if(croppingParams === null) {
        gl.viewport(0, 0, width, height);
    } else {
        gl.viewport(0, 0, croppingParams.width, croppingParams.height);

        var tTop = croppingParams.top / height;
        var tLeft = croppingParams.left / width;
        var tBottom = croppingParams.height / height;
        var tRight = croppingParams.width / width;
        var texturePosValues = new Float32Array([tRight, tTop, tLeft, tTop, tRight, tBottom, tLeft, tBottom]);

        gl.bindBuffer(gl.ARRAY_BUFFER, texturePosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texturePosValues, gl.DYNAMIC_DRAW);
    }

    var i420Data = data;

    var yDataLength = width * height;
    var yData = i420Data.subarray(0, yDataLength);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, yTextureRef);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, yData);

    var cbDataLength = width/2 * height/2;
    var cbData = i420Data.subarray(yDataLength, yDataLength + cbDataLength);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, uTextureRef);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width/2, height/2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, cbData);

    var crDataLength = cbDataLength;
    var crData = i420Data.subarray(yDataLength + cbDataLength, yDataLength + cbDataLength + crDataLength);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, vTextureRef);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width/2, height/2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, crData);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); 
};

/**
 * Draw next output picture using ARGB data on a 2d canvas.
 */
H264bsdCanvas.prototype.drawNextOuptutPictureRGBA = function(width, height, croppingParams, data) {
    var canvas = this.canvasElement;

    var croppingParams = null;

    var argbData = data;

    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0, 0, width, height);
    imageData.data.set(argbData);

    if(croppingParams === null) {
        ctx.putImageData(imageData, 0, 0);
    } else {
        ctx.putImageData(imageData, -croppingParams.left, -croppingParams.top, 0, 0, croppingParams.width, croppingParams.height);
    }
};
  
  return H264bsdCanvas;
  
}));

function appendByteArray(buffer1, buffer2) {
    let tmp = new Uint8Array((buffer1.byteLength|0) + (buffer2.byteLength|0));
    tmp.set(buffer1, 0);
    tmp.set(buffer2, buffer1.byteLength|0);
    return tmp;
}
function RTPU(pkt,idx) {
    let bytes = new DataView(pkt.buffer, idx+2, 8);
    this.payload = pkt.subarray(12);
    this.timestamp = bytes.getFloat64(0);
    // console.log(this.timestamp);
}
function NALU(_ntype, _nri, _data, _timestamp) {
    this.data      = _data;
    this.ntype     = _ntype;
    this.nri       = _nri;
    this.timestamp = _timestamp;
}

function STMCPlayer(ws_src) {
    this._dltimeout = 5000;
    this._currentMetaTS = 10;
    this.started = false;
    this._ws_src = ws_src;
    this._canvas = document.createElement('canvas');
    this._buffer = [];
    this.sps = false;
    this.nalu_l = null;
    this.ts_l = 0;

    let seqMap = new Map();
    _Helper.seqMap.push(seqMap);
    this.seqM_idx = _Helper.seqMap.length-1;
    this.seqMap =  _Helper.seqMap[this.seqM_idx];
    this.onFrame = function(e){};

    this.openSocket(this._ws_src);
    self = this;
    setInterval(
        self.flush.bind(self),100
    );
}

STMCPlayer.prototype.parseWsData = function(data){
    console.log('parsing',data);
    let view = new DataView(data.buffer);
    let idx = 0;

    while(idx < view.byteLength-2){
        let len = view.getUint16(idx);
        let nal_header =  view.getUint8(idx+12);
        let nal_type = nal_header & 0x1f;

        if (idx+2+len-1< view.byteLength && idx+12 < view.byteLength){
            idx +=  2 + len;            
        }            
    }        
    console.log(view.byteLength, idx);
}

STMCPlayer.prototype.flush = function(max=null){
    // console.log('flush')
    if (!max)
        max = this._currentMetaTS;

    for (var [key, value] of this.seqMap) {
        if (value) {
            this.slicePkts(value);
            this.seqMap.delete(key);            
        }
        else break;
    }
}

STMCPlayer.prototype.downloadPacket = function(packet_id){
    this.seqMap.set(packet_id,null);
    let packet_url = this.baseurl + packet_id;
    let xhr = new XMLHttpRequest();
    let self = this;
    xhr.packet_id = packet_id;
    xhr.seqM_idx = this.seqM_idx;
    xhr.responseType = 'arraybuffer';
    xhr.timeout = this._dltimeout;
    xhr.open('GET', this.baseurl.concat(packet_id), true);
    xhr.onload = function () {
        if (this.status == 200) {
            let seqMap = _Helper.seqMap[this.seqM_idx];
            if (seqMap.has(this.packet_id))            
                seqMap.set(this.packet_id, this.response);
        }
        else{
            if (seqMap.has(this.packet_id))            
                seqMap.delete(this.packet_id);
        }
       // self.flush();
    }
    let handler = function (e) {
        try {            
            if (seqMap.has(this.packet_id))            
                seqMap.delete(this.packet_id);     
        } catch (e){}
        // self.flush();
    }
    xhr.onerror = handler;
    xhr.ontimeout = handler;    
    xhr.send(null);
}

STMCPlayer.prototype.onMsgReicv = function (msg) {
    if (typeof msg.data == 'string') {
        let match = msg.data.match(/\[([0-9]+), .+,.+,(.+[0-9]+).+/);
        if (match) {
            // console.log(match[2]);
            if (this.started || match[2].match(/78[05]/)){ 
                this.started = true;
                this.downloadPacket(match[1]);  
            }
        }
    }
}

STMCPlayer.prototype.onSkOpen = function (msg) {
    this._ws.send('{ "action":"hello", "version":"2.0", "host_id":"' + this.host_id + '", "signature":"RESERVED", "timestamp":"1480371820539" }');
}

STMCPlayer.prototype.openSocket = function () {
    let match_url = this._ws_src.match(/ws[s]*:\/\/(.+)\/evup\/(.+)\/(.+)/);

    if (match_url) {
        this.host_id = match_url[2];
        this.baseurl = `https://${match_url[1]}/live/g/${match_url[3]}/`;
        this._ws = new WebSocket(this._ws_src);

        let self = this;
        this._ws.onopen = this.onSkOpen.bind(this);
        this._ws.onmessage = this.onMsgReicv.bind(this);
    }
}

STMCPlayer.prototype.parseNALU = function(rtpu) {
    let ret = null;
    let nalhdr =  rtpu.payload[0];
    let nri = nalhdr & 0x60;
    let naltype = nalhdr & 0x1F;
    let nal_start_idx = 1;
    switch(naltype) {
        case 7:
        case 8:
        case 5:
        case 1:
            ret = new NALU(naltype, nri, rtpu.payload.subarray(1), rtpu.timestamp);
            break;
        case 28: // FU-A
        {
            nal_start_idx = 2;
            let nalfrag = rtpu.payload[1];
            let nfstart = (nalfrag & 0x80) >>> 7;
            let nfend = (nalfrag & 0x40) >>> 6;
            let nftype = nalfrag & 0x1F;
            // console.log(naltype," ",nfstart," ",nfend," ",nftype)
            if (nfstart) {
                this.ts_l = rtpu.timestamp;
                this.nalu_l = rtpu.payload.subarray(2);
            }
            else if (this.nalu_l && (this.ts_l === rtpu.timestamp)) {
                let temp = appendByteArray(this.nalu_l, rtpu.payload.subarray(2));
                if(nfend) {
                    ret = new NALU(nftype, nri, temp, rtpu.timestamp);
                    this.nalu_l = null;
                }
                else {
                    this.nalu_l = temp;
                }
            }
            else {
                console.log('error [FU-A].... ')
            }
        }
            break;
        default:
            break;
    }
    return ret;
}

STMCPlayer.prototype.slicePkts = function(data){
    let raw  = new Uint8Array(data);
    let view = new DataView(data);
    let idx = 0;
    
    while(idx < view.byteLength-2){
        let len = view.getUint16(idx);
        if (idx+2+len-1< view.byteLength && idx+12 < view.byteLength){
            let packet_feed = raw.subarray(idx,idx+len+2);
            let nalu = this.parseNALU(new RTPU(packet_feed,idx));
            if(nalu) {
                this.onFrame(nalu);
            }
            idx +=  2 + len;
        }
        else
            break;
    }
}

_Helper = {
    seqMap : []
}

let mhelper = {
    version:"20100119-1317",
    debug_full: false,
    debug_en: false,
    debug_ws: false,
    debug_tk: false,
    debug_re: false,
    debug_dc: false,
};

let TS_STATE = {
    NONE: 0x00,
    ONLY_WS: 0x01,
    ONLY_EN: 0x02,
    FULL: 0x03
};

function MixedItem() {
    this.timestamp = 0;
    this.buffer = null;
    this.einfo = [];
}

function tlog(msg, option = false) {
    if (mhelper.debug_full || option) {
        console.log(msg);
    }
}

function Mixer() {
    this.enbuffer = [];
    this.wsbuffer = [];
    this.pics = [];

    this.curTs = 0;
    this.enTs = 0;
    this.wsTs = 0;
    this.nextEnItem = new MixedItem();
    this.nextWsItem = new MixedItem();

    this.enRunning = false;
    this.wsRunning = false;
    this.firstMatching = false;
    this.firstTs = 0;
    this.tick();
}
Mixer.prototype.pushEngine = function (pkg) {
    if(pkg.timestamp) {
        if (!this.enRunning) {
            console.log("[matching] Engine started");
            this.enRunning = true;
            this.nextEnItem = pkg;
        }
        else {
            if (!this.wsRunning) return;
            if (this.enbuffer.length < 200) {
                this.enbuffer.push(pkg);
            }
        }
    }
}
Mixer.prototype.pushWs = function (pkg) {
    if (pkg.timestamp) {
        if (!this.wsRunning) {
            console.log("[matching] WS started");
            this.wsRunning = true;
            this.nextWsItem = pkg;
        }
        else {
            if (this.wsbuffer.length < 200) {
                this.wsbuffer.push(pkg);
                if (!this.enRunning) {
                    this.release();
                    this.nextWsItem = this.wsbuffer.shift();
                }
            }
        }
    }
}
Mixer.prototype.push = function (msg = '', pkg) {
    if (msg == 'engine') {
        this.pushEngine(pkg);
    }
    else {
        this.wsbuffer.push(pkg);
    }
}
Mixer.prototype.nextEn = function (sub = 0) {
    tlog("_nextEn[ws-en] " + this.wsbuffer.length+" "+this.enbuffer.length, mhelper.debug_en);
    if (this.wsbuffer.length > 25*8) {
        this.release();
        this.nextWsItem = this.wsbuffer.shift();
    }
    if (this.enbuffer.length) {
        this.nextEnItem = this.enbuffer.shift();
        this.tick();
    }
    else if (sub > 100) {
        setTimeout(this.nextEn.bind(this), 5);
    }
    else {
        setTimeout(this.nextEn.bind(this), 20);
    }
}
Mixer.prototype.nextWs = function (sub = 0) {
    tlog("_nextWs[ws-en] " + this.wsbuffer.length+" "+ this.enbuffer.length, mhelper.debug_ws);
    if (this.wsbuffer.length) {
        this.nextWsItem = this.wsbuffer.shift();
        if (this.wsbuffer.length > 25*8) {
            this.release();
            this.nextWsItem = this.wsbuffer.shift();
        }
        this.tick();
    }
    else if (sub > 100) {
        setTimeout(this.nextWs.bind(this), 5);
    }
    else {
        setTimeout(this.nextWs.bind(this), 20);
    }
}
Mixer.prototype.tick = function () {
    tlog("_tick[ws-en] " + this.wsbuffer.length +" "+ this.enbuffer.length, mhelper.debug_tk);
    if (this.enRunning && this.wsRunning) {
        let enTs = this.nextEnItem.timestamp;
        let wsTs = this.nextWsItem.timestamp;
        let sub = Math.abs(enTs - wsTs);
        tlog("_tick[ws-en]: " + wsTs + "-" + enTs + "=" + (wsTs - enTs), mhelper.debug_tk);
        if (enTs < wsTs) {
            this.nextEn(sub);
        }
        else {
            this.release();
            this.nextWs(sub);
        }
    }
    else {
        setTimeout(this.tick.bind(this), 30);
    }
}
Mixer.prototype.release = function () {
    let pic = new MixedItem();
    pic = this.nextWsItem;
    let enTs = this.nextEnItem.timestamp;
    let wsTs = this.nextWsItem.timestamp;
    let compare = Math.abs(wsTs-enTs);
    if (compare < 20) {
        pic.state = TS_STATE.FULL;
        pic.einfo = this.nextEnItem.einfo;
        if (!this.firstMatching && (enTs == wsTs)) {
            console.log("[matching] first matching");
            this.firstMatching = true;
            this.firstTs = wsTs;
        }
    }
    else {
        pic.state = TS_STATE.ONLY_WS;
    }
    tlog("_release[ws-en]: " + wsTs + "-" + enTs + "=" + (wsTs - enTs), mhelper.debug_re);
    this.pics.push(pic);
}



function Size(w,h)
{
    this.width = w;
    this.height = h;
}
function Rect(x,y,w,h)
{
    this.x=x;
    this.y=y;
    this.width=w;
    this.height=h;
}
function scale(r,xunit,yunit)
{
    return new Rect(r.x*xunit, r.y*yunit, r.width*xunit, r.height*yunit);   
}
function drawRect(ctx,r) {
    ctx.rect(r.x,r.y,r.width,r.height);
}
function EslapedTime(max)
{
    this.start = 0;
    this.end = 0;
    this.time = 0;
    this.duration = 0;
    this.avg = 0;
    this.queue = [];
    let self = this;

    this.setPoint = function() {
        let last = this.time;
        this.time = new Date();
        this.duration = this.time-last;
        if (this.queue.length>max) this.queue.shift();
        this.queue.push(this.duration);
        let sum = 0;
        for(let ii=0;ii<this.queue.length;ii++) {
            sum += parseInt(this.queue[ii], 10 );
        }
        this.avg = sum/this.queue.length;
    }
}

let config = {
    size: new Size(1920,1080),
    tracking:{
        color:"red",
        thickness:4,
    },
    cropArea:{
        color:"red",
        thickness:5,
        rect: new Rect(50,600,1800,400)
    },
}

function Player(input, enableMatching=true)
{
    let self = this;
    this.width=1280;
    this.height=720;
    this.fps = 40;//1000/25=40
    this.frames = [];
    this.firstFrame = false;
    this.elapsedDecoder = new EslapedTime(25);
    this.firstDraw = false;
    this.debug_decoder = false;
    this.debug_enSocket = false;
    this.debug_fps = false;
    this.avg = 0;
    this.xrate = 1;
    this.yrate = 1;

    this.en_url = input.en_url;
    this.ws_url = input.ws_url;
    if (input.canvas) {
        this.mainLayer= canvas[0];
        this.matchingLayer= canvas[1];
        this.cropLayer= canvas[2];
    }
    else {
        this.mainLayer = document.getElementById('videocanvas');
        this.matchingLayer = document.getElementById('rectcanvas');
        this.cropLayer = document.getElementById('cropcanvas');
    }

    this.display = new WebGLCanvas(this.mainLayer);
    this.decoder = new Worker('js/decoder/decoder.js');
    this.mixer = new Mixer();
    this.decoder.addEventListener('message', function(e){
        self.decoderCallback(e);
    });

    this.h264reader = new STMCPlayer(this.ws_url);
    this.h264reader.onFrame = function(e) {
        self.push2Decoder(e);
    };

    if (enableMatching) {
        this.socket = io.connect(this.en_url);
        this.socket.on('engineInfo', function(e){
            self.pushEngineInfo(e);
        });
    }

    this.draw();
}

Player.prototype.update = function() {
    this.xrate = this.width/config.size.width;
    this.yrate = this.height/config.size.height;
}

function download(data, filename, type) {
    var file = new Blob([].concat.apply([],data), { type: type });
    if (window.navigator.msSaveOrOpenBlob) // IE10+
        window.navigator.msSaveOrOpenBlob(file, filename);
    else { // Others
        var a = document.createElement("a"),
            url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function () {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
}

Player.prototype.writeFile = function() {
    download(this.frames, 'ws');
}

Player.prototype.writeFile2 = function() {
    let findex = 0;
    let fpr = false;
    setInterval(function () {
        if (fpr) {
            findex++;
            download(_curBuffer, 'web_all', 'text');
        }
    }, 3000);
}

Player.prototype.print = function() {
    console.log('print')
    console.log(this.fps)
    console.log(this.mixer.pics.length)
    console.log(this.mixer.wsbuffer.length)
    console.log(this.mixer.enbuffer.length)
}

Player.prototype.decoderCallback = function(e) {
    this.elapsedDecoder.setPoint();
    if (this.debug_decoder) {
        let tt = this.elapsedDecoder.duration;
        let avg = this.elapsedDecoder.avg;
        let stime = e.data.elapsedTime;
        stime.duration = this.elapsedDecoder.duration;
        stime.fpsAvg = parseInt(this.elapsedDecoder.avg, 10);
        console.log("_dccallback =>> ",stime)
    }
    let message = e.data;
    if (message.data && message.timestamp) {
        // console.log(message)
        if (!this.firstFrame) {
            this.firstFrame = true;
            console.log("firstFrame:",message.timestamp,message.width,message.height);
            this.width = message.width;
            this.height = message.height;
            let canvas = document.getElementsByTagName("canvas");
            for (c of canvas){
                c.width = this.width;
                c.height = this.height;
            }
            this.update();
        }
        let it = new MixedItem();
        it.timestamp = message.timestamp;
        it.buffer = message.data;
        this.mixer.pushWs(it);
    }
}

Player.prototype.push2Decoder = function(nalu) {
    let frame = appendByteArray(new Uint8Array([0,0,1,nalu.ntype|nalu.nri]),nalu.data);
    this.decoder.postMessage({type:'frame', data:frame, timestamp:nalu.timestamp});
}

Player.prototype.pushEngineInfo = function(message) {    
    if (this.debug_enSocket) {
        console.log(message);
    }
    let it = new MixedItem();
    it.timestamp = message.timestamp;
    it.einfo = message.rects?message.rects:[];
    this.mixer.pushEngine(it);
}

Player.prototype.fpsCalculator = function(n) {
    let fpsmin=25,fpsnor=38,fpsmax = 50,fpsflush_1 = 10, fpsflush_2 = 1;
    let snor =10,smax = 100,smin = 3;
    let lastfps = this.fps;
    let curfps = fpsnor;

    if(n > snor && n < smax) {
        curfps = (fpsnor - (fpsnor-fpsmin)*(n-snor)/(smax-snor));
    }    
    else if (n < snor) {
        curfps = fpsnor + (fpsmax-fpsnor)*(snor-n)/(snor-smin);
    }
    else if (n < smin) {
        curfps = fpsnor + 5*(8-n);        
    }
    else if (n > (2*smax)) {
        curfps = fpsflush_1;
    }
    else {
        curfps = fpsflush_2;
    }

    if (curfps < lastfps) {
        curfps = Math.max(curfps,lastfps-5);
    }
    else {
        curfps = Math.min(curfps,lastfps+5);
    }
    // curfps = 20;
    if (this.debug_fps) {
        console.log('_fps =>> ',n,curfps)
    }
    return curfps;
}

Player.prototype.fpsCalculator2 = function(n) {
    let fpsmin=25,fpsmax=40, fpsflush_1 = 10, fpsflush_2 = 1;
    let smin =200,smax = 300;
    if (n < smin) {
        return fpsmax;
    }
    else if(n > smin && n < smax) {
        return (fpsmax - (fpsmax-fpsmin)*(n-smin)/(smax-smin));
    }
    else if (n > (2*smax)) {
        return fpsflush_1;
    }
    else {
        return fpsflush_2;
    }
}

Player.prototype.drawCropArea = function() {
    // let ctx = document.getElementById("cropcanvas").getContext("2d");
    let ctx = this.cropLayer.getContext("2d");
    ctx.clearRect(0, 0, this.width, this.height);
    ctx.beginPath();
    ctx.lineWidth = config.cropArea.thickness;
    ctx.strokeStyle = config.cropArea.color;
    let r = new Rect(config.cropArea.rect.x, config.cropArea.rect.y,
            config.cropArea.rect.width, config.cropArea.rect.height)
    let dr = scale(r,this.xrate,this.yrate);
    ctx.rect(dr.x,dr.y,dr.width,dr.height);
    ctx.stroke();
}

Player.prototype.draw = function(n) {
    if (this.mixer.pics.length) {
        let item = this.mixer.pics.shift();
        let picBuffer = item.buffer;
        this.fps = this.fpsCalculator(this.mixer.pics.length);
        setTimeout(this.draw.bind(this), this.fps);
        let croppingParams = {
            width: 640,
            height: 480,
            left: 0,
            top:0,
        }
        croppingParams = null;
        this.display.drawNextOuptutPictureGL(this.width,this.height,croppingParams,picBuffer);
        this.drawMatchingInfo(item);
    }
    else {
        setTimeout(this.draw.bind(this), 10);
    }
}

Player.prototype.drawMatchingInfo = function(item) {
    // let ctx = document.getElementById("rectcanvas").getContext("2d");
    let ctx = this.matchingLayer.getContext("2d");
    ctx.clearRect(0,0,1920,1080);
    if (item.state == TS_STATE.FULL) {
        if (item.einfo.length) {
            ctx.beginPath();
            ctx.lineWidth = config.tracking.thickness;
            ctx.strokeStyle = config.tracking.color;
            for (c of item.einfo) {
                let r = new Rect(c.x,c.y,c.width,c.height);
                let dr = scale(r,this.xrate,this.yrate);
                ctx.rect(dr.x,dr.y,dr.width,dr.height);
            }
            ctx.stroke();
        }
        if (!this.firstDraw) {
            console.log("draw croparea");
            this.firstDraw = true;
            // this.drawCropArea();
        }
    }
}